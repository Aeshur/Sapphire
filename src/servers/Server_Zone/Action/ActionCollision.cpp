#include <src/servers/Server_Common/Util/Util.h>
#include <src/servers/Server_Common/Exd/ExdData.h>
#include <src/servers/Server_Common/Util/UtilMath.h>

#include "ActionCollision.h"
#include <src/servers/Server_Zone/Actor/Actor.h>
#include <src/servers/Server_Zone/Actor/Player.h>
#include <cmath>
#include <boost/make_shared.hpp>

using namespace Core::Entity;
using namespace Core::Common;

// todo: add filters for allies, enemies only etc

bool ActionCollision::isActorCollisionValid( ActorPtr actorPtr, AoeFilter aoeFilter )
{
   bool collisionApplicable = false;
   switch ( aoeFilter )
   {
   case AoeFilter::All:
   {
      collisionApplicable = true;
   }
   case AoeFilter::Players:
   {
      collisionApplicable = actorPtr->isPlayer();
   }
   case AoeFilter::Allies:
   {
      // todo: implement ally NPCs
      collisionApplicable = !actorPtr->isMob();
   }
   case AoeFilter::Party:
   {
      // todo: implement party
      collisionApplicable = actorPtr->isPlayer();
   }
   case AoeFilter::Enemies:
   {
      collisionApplicable = actorPtr->isMob();
   }
   }

   return ( collisionApplicable && actorPtr->isAlive() );
}

std::set< Core::Entity::ActorPtr > ActionCollision::getActorsHitFromAction( FFXIVARR_POSITION3 aoePosition, std::set< ActorPtr > actorsInRange, boost::shared_ptr< Core::Data::ActionInfo > actionInfo, AoeFilter aoeFilter )
{
   std::set< ActorPtr > actorsCollided;

   switch ( static_cast< ActionCollisionType >( actionInfo->aoe_type ) )
   {
   case ActionCollisionType::None:
   case ActionCollisionType::SingleTarget:
   {
      // This is actually needed. There is "splash damage" in actions marked as single target.
      // Notice how we're using aoe_width. How collision works for SingleTarget is unknown as of now.
      // TODO: Isn't it possible to stack 2 players in the same spot and glitch the action collision this way? Investigate
      for ( auto pActor : actorsInRange )
      {
         // Make sure actor exists. If it doesn't we done goofed.
         assert( pActor );

         // Don't bother wasting on collision if actor doesn't apply for it
         if ( !isActorCollisionValid( pActor, aoeFilter ) )
            break;

         // Test our collision from actor with the area generated by the action from the AoE data
         if ( radiusCollision( pActor->getPos(), aoePosition, actionInfo->aoe_width ) )
         {
            // Add it to the actors collided with the area
            actorsCollided.insert( pActor );
         }
      }
      break;
   }
   case ActionCollisionType::Circle:
   {
      for ( auto pActor : actorsInRange )
      {
         assert( pActor );

         if ( !isActorCollisionValid( pActor, aoeFilter ) )
            break;

         if ( radiusCollision( pActor->getPos(), aoePosition, actionInfo->aoe_range ) )
         {
            actorsCollided.insert( pActor );
         }
      }
      break;
   }
   case ActionCollisionType::Box:
   {
      for ( auto pActor : actorsInRange )
      {
         assert( pActor );

         if ( !isActorCollisionValid( pActor, aoeFilter ) )
            break;

         if ( boxCollision( pActor->getPos(), aoePosition, actionInfo->aoe_width, actionInfo->aoe_range ) )
         {
            // todo: does this actually work?

            actorsCollided.insert( pActor );
         }
      }
      break;
   }
   default:
   {
      break;
   }
   }

   return actorsCollided;
}

bool ActionCollision::radiusCollision( FFXIVARR_POSITION3 actorPosition, FFXIVARR_POSITION3 aoePosition, uint16_t radius )
{
   return Core::Math::Util::distance( actorPosition.x, actorPosition.y, actorPosition.z,
      aoePosition.x, aoePosition.y, aoePosition.z ) <= radius;
}

bool ActionCollision::boxCollision( FFXIVARR_POSITION3 actorPosition, FFXIVARR_POSITION3 aoePosition, uint16_t width, uint16_t height )
{
   return actorPosition.x < aoePosition.x + width &&
      actorPosition.x > aoePosition.x &&
      actorPosition.y < aoePosition.y + height &&
      actorPosition.y > aoePosition.y;
}